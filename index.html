<!DOCTYPE html>
<html>
  <head>
    <script type='module' src="./sim.mjs"></script>
    <style type='text/css'>
      body {
          margin:0; padding:0;
          background-color: black;
          overflow:hidden;
      }
      div {
          font-family: monospace;
          position: fixed;
          color: white;
      }
      #ctrls { left: 5px; top: 5px; }
        #step { display: none; }
      #pedit { left: 5px; top: 35px; text-align: right; }
      #nav { right: 5px; top: 5px; }
      #info { right: 5px; top: 25px; text-align: right; }
      #inspect { margin-left: 20px; display: none; }
      #partidx { width: 70px; text-align: right; }
      input[type=range] {
          vertical-align: middle;
          width: 200px;
      }
      
    </style>

          
    <script type='module'>
      const { cos, sin, acos, asin, cbrt, sqrt, PI, random, ceil, floor, tan, max, min, log2,round,atan } = Math
      const _ = sel => document.querySelector(sel)
      const __ = sel => document.querySelectorAll(sel)
      window.App = class App {
          constructor() {
              this.canvas = document.querySelector('canvas')
              this.canvas.width = this.canvas.style.width = window.innerWidth
              this.canvas.height = this.canvas.style.height = window.innerHeight
              this.ctx = this.canvas.getContext('webgpu')
              this.sim = new Sim()
              this.sim.init(this.canvas.width,this.canvas.height,this.ctx).then(()=> {
                  this.setup()
                  this.sim.run()
              })        
          }


          setup() {
              const { render, compute, possessed, params, particles } = this.sim
              const cv = this.canvas                           
              
              _('#step').style.display = _('#inspect').style.display = localStorage.paused ? 'inline' : 'none'
              _('#partidx').max = particles.length - 1              
              _('#pedit').innerHTML = Params.fields.map(field => {
                  const name = field.name
                  const val = localStorage[name] == undefined ? params[name] : parseFloat(localStorage[name])
                  const lo = 0, hi = params[name] * 4.9
                  return `${name} <input type='range' name='${name}' value='${val}' `+
                      `min='${lo}' max='${hi}' step='0.001' ` +
                      `oninput='${name}.value=parseFloat(this.value).toFixed(3); localStorage.${name} = this.value'/> ` +
                      `<output id='${name}'>${val.toFixed(3)}</output>`
              }).join('<br/>')
              this.move = false
              cv.onmouseup = cv.onmouseout = cv.onmousedown = cv.onmousemove = cv.onwheel = cv.oncontextmenu =
                  _('#pause').onclick = _('#step').onclick = window.onresize = _('#partidx').oninput = (ev) => { this.handle(ev) }
              
              setTimeout(()=>{ this.updateInfo() }, 500)
             
          }

          handle(ev) {
              const sim = this.sim
              const { compute, render, gpu, bufs, possessed, camera } = sim
              if (ev.target == _('#pause') && ev.type == 'click') {
                  compute.paused = !compute.paused
                  _('#step').style.display = _('#inspect').style.display = compute.paused ? 'inline' : 'none'
              }
              
              if (ev.target == _('#step') && ev.type == 'click') {
                  compute.fwdstep = true
              }
              
              if (ev.target == _('#partidx') && ev.type == 'input') {
                  const pidx = parseInt(_('#partidx').value)
                  camera.selection = pidx
              }
              
              if (ev.type == 'mousedown') {
                  this.move = {x: ev.x, y: ev.y, btn: ev.button}
              }
              
              if (ev.type == 'mouseout' || ev.type == 'mouseup') {
                  this.move = false;
              }
              
              if (ev.type == 'mousemove') {
                  if (!this.move) return
                  const dx = .01*(ev.x - this.move.x), dy = .01*(this.move.y - ev.y)
                  this.move.x = ev.x
                  this.move.y = ev.y
                  if (this.move.btn == 0) {
                      sim.camLR += dx
                      sim.camUD = clamp(sim.camUD + dy,-PI/2, PI/2)
                  } else if (this.move.btn == 1) {
                      const delta = Vec3.of( -dx * cos(sim.camLR), dx * sin(sim.camLR), -dy);
                      sim.camPos = sim.camPos.add(delta)
                  }
              }
              
              if (ev.type == 'wheel') {
                  const dy = -.001 * ev.deltaY
                  const camDir = sim.camFwd()
                  sim.camPos.x += dy * camDir.x
                  sim.camPos.y += dy * camDir.y
                  sim.camPos.z += dy * camDir.z
              }
              
              if (ev.type == 'contextmenu') {
                  ev.preventDefault()
              }
              
              if (ev.type == 'resize') {
                  this.canvas.width = this.canvas.style.width = window.innerWidth
                  this.canvas.height = this.canvas.style.height = window.innerHeight
                  sim.resize(this.canvas.width, this.canvas.height)
              }
            
          }
    
          async updateInfo() {
              const {compute, render, camPos} = this.sim
              let { tstart, tlast, frames, stamps, labels, tsim } = await compute.stats()
              const lines = []
              if (frames != undefined) {
                  lines.push(`compute trel:${((tlast - tsim)*1000).toFixed(2)} ms`)
                  lines.push(`compute fps:${(frames/(tlast-tstart)).toFixed(2)}`)
                  if (labels.length) {
                      lines.push(...Array.from(range(1,labels.length)).map(i => `${labels[i]}: ${(stamps[i] - stamps[i-1])/1000n} &mu;s`))
                      lines.push(`total: ${(stamps[labels.length-1] - stamps[0])/1000n} &mu;s`)
                  }
              }
              ({ tstart, tlast, frames } = await render.stats());
              lines.push(`render fps:${(frames/(tlast-tstart)).toFixed(2)}`)
              _('#info').innerHTML = lines.join('<br/>')
              _('#nav').innerText = `cam: pos=${camPos.toString()} fwd=${this.sim.camFwd().toString()}`
              setTimeout(() => { this.updateInfo() }, 500)
          }
          
      }      
    </script>
  </head>
  <body onload='window.app = new App()'>
    <canvas></canvas>
    <div id='info'></div>
    <div id='ctrls'>
      <button id='pause'>&#9199;</button>
      <button id='step'>&#11122;</button>
      <div id='inspect'>
        particle: <input id='partidx' type='number' min='0' max='${particles.length - 1}' value=''>
      </div>      
    </div>
    <div id='nav'></div>
    <div id='pedit'></div>      
  </body>
</html>
